name: Build Packages and Publish Helm Charts

on:
  push:
    branches:
      - 'main'
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  detect-changes:
    if: github.actor != 'github-actions[bot]'
    runs-on: ubuntu-latest
    outputs:
      changed-components: ${{ steps.changes.outputs.changed-components }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed components
        id: changes
        run: |
          # Get changed files
          CHANGED_FILES=$(git diff --name-only ${{ github.event.before }}..HEAD)

          # Get all helm components
          ALL_COMPONENTS=$(find . -maxdepth 3 -name "Chart.yaml" -path "*/helm/Chart.yaml" | cut -d'/' -f2 | sort | uniq)

          echo "Changed files:"
          echo "=============="
          echo "$CHANGED_FILES"
          echo ""

          echo "All components:"
          echo "==============="
          echo "$ALL_COMPONENTS"
          echo ""

          # Check if workflow changed
          if echo "$CHANGED_FILES" | grep -q "^\.github/workflows/"; then
            # Workflow changed, process all components
            CHANGED_COMPONENTS="$ALL_COMPONENTS"
            echo "Workflow changed - processing all components"
          else
            # Find components with changes
            CHANGED_COMPONENTS=""
            for component in $ALL_COMPONENTS; do
              if echo "$CHANGED_FILES" | grep -q "^${component}/"; then
                CHANGED_COMPONENTS="$CHANGED_COMPONENTS $component"
              fi
            done
          fi

          # Trim whitespace
          CHANGED_COMPONENTS=$(echo $CHANGED_COMPONENTS | xargs)

          echo "Changed components: $CHANGED_COMPONENTS"
          echo "changed-components=$CHANGED_COMPONENTS" >> $GITHUB_OUTPUT

  construct-build-matrix:
    needs: detect-changes
    if: needs.detect-changes.outputs.changed-components != ''
    runs-on: ubuntu-latest
    outputs:
      build-matrix: ${{ steps.matrix.outputs.build-matrix }}
      has-builds: ${{ steps.matrix.outputs.has-builds }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Construct build matrix from build.yaml files
        id: matrix
        run: |
          CHANGED_COMPONENTS="${{ needs.detect-changes.outputs.changed-components }}"

          # Initialize empty matrix
          MATRIX_JSON='{"include":[]}'

          for component in $CHANGED_COMPONENTS; do
            BUILD_FILE="${component}/build.yaml"

            if [ -f "$BUILD_FILE" ]; then
              echo "Found build.yaml for $component"

              # Read builds from YAML and convert to JSON matrix entries
              CHART_PATH="${component}/helm/Chart.yaml"

              # Process each build entry
              BUILD_COUNT=$(yq eval '.builds | length' "$BUILD_FILE")

              for ((i=0; i<BUILD_COUNT; i++)); do
                NAME=$(yq eval ".builds[$i].name" "$BUILD_FILE")
                CONTAINERFILE=$(yq eval ".builds[$i].containerfile" "$BUILD_FILE")
                CONTEXT=$(yq eval ".builds[$i].context" "$BUILD_FILE")

                # Create matrix entry
                ENTRY=$(jq -n \
                  --arg name "$NAME" \
                  --arg file "${component}/${CONTAINERFILE}" \
                  --arg context "${component}/${CONTEXT}" \
                  --arg chart "$CHART_PATH" \
                  --arg component "$component" \
                  '{name: $name, file: $file, context: $context, chart: $chart, component: $component}')

                # Add to matrix
                MATRIX_JSON=$(echo "$MATRIX_JSON" | jq --argjson entry "$ENTRY" '.include += [$entry]')
              done
            else
              echo "No build.yaml for $component - skipping image builds"
            fi
          done

          echo "Final build matrix:"
          echo "$MATRIX_JSON" | jq .

          # Check if we have any builds
          BUILD_COUNT=$(echo "$MATRIX_JSON" | jq '.include | length')
          if [ "$BUILD_COUNT" -gt 0 ]; then
            echo "has-builds=true" >> $GITHUB_OUTPUT
          else
            echo "has-builds=false" >> $GITHUB_OUTPUT
          fi

          echo "build-matrix=$(echo "$MATRIX_JSON" | jq -c .)" >> $GITHUB_OUTPUT

  update-versions-and-tag:
    needs: detect-changes
    if: needs.detect-changes.outputs.changed-components != ''
    runs-on: ubuntu-latest
    outputs:
      commit-shas: ${{ steps.push.outputs.commit-shas }}
      final-sha: ${{ steps.push.outputs.final-sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update versions, create tags, and push
        id: push
        run: |
          CHANGED_COMPONENTS="${{ needs.detect-changes.outputs.changed-components }}"

          # Initialize JSON map for component -> commit SHA
          COMMIT_SHAS_JSON='{}'

          # Process each component: update version, commit, and tag
          for component in $CHANGED_COMPONENTS; do
            CHART_PATH="${component}/helm/Chart.yaml"

            if [ ! -f "$CHART_PATH" ]; then
              echo "Skipping $component - no Chart.yaml found"
              continue
            fi

            echo "Processing $component..."

            # Read current version (might have +N from previous build)
            current_version=$(grep '^version:' "$CHART_PATH" | awk '{print $2}')

            # Strip existing +N to get base version
            base_version="${current_version%+*}"

            echo "  Current version: $current_version"
            echo "  Base version: $base_version"

            # Count existing tags for this base version
            tag_pattern="${component}-${base_version}+*"
            existing_count=$(git tag -l "$tag_pattern" | wc -l)
            next_build=$((existing_count + 1))

            # Create new version with build number
            new_version="${base_version}+${next_build}"
            echo "  New version: $new_version"

            # Update Chart.yaml
            sed -i "s/^version: .*/version: $new_version/" "$CHART_PATH"

            # Get appVersion for tag message
            app_version=$(grep '^appVersion:' "$CHART_PATH" | awk '{print $2}' | tr -d '"')

            # Commit this component's version update
            git add "$CHART_PATH"
            git commit -m "chore(${component}): bump version to ${new_version}"

            # Get the commit SHA for this component
            COMMIT_SHA=$(git rev-parse HEAD)

            # Add to JSON map
            COMMIT_SHAS_JSON=$(echo "$COMMIT_SHAS_JSON" | jq --arg component "$component" --arg sha "$COMMIT_SHA" '. + {($component): $sha}')

            # Create annotated tag for this commit
            tag_name="${component}-${new_version}"
            git tag -a "$tag_name" -m "Release ${component} version ${new_version}

Version: ${new_version}
App version: ${app_version}
Commit: $(git rev-parse --short HEAD)"

            echo "Created commit and tag: $tag_name (SHA: $COMMIT_SHA)"
          done

          # Push all commits and tags together
          git push origin main --follow-tags

          # Get final commit SHA (includes all component bumps)
          FINAL_SHA=$(git rev-parse HEAD)

          # Output the JSON map of component -> commit SHA
          echo "commit-shas=$(echo "$COMMIT_SHAS_JSON" | jq -c .)" >> $GITHUB_OUTPUT
          echo "final-sha=$FINAL_SHA" >> $GITHUB_OUTPUT
          echo "Component commit SHAs:"
          echo "$COMMIT_SHAS_JSON" | jq .
          echo "Final SHA: $FINAL_SHA"

  build-and-push:
    needs: [construct-build-matrix, update-versions-and-tag]
    if: github.repository == 'rh-ai-quickstart/ai-architecture-charts' && needs.construct-build-matrix.outputs.has-builds == 'true'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.construct-build-matrix.outputs.build-matrix) }}

    steps:
      - name: Checkout tagged commit
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ fromJson(needs.update-versions-and-tag.outputs.commit-shas)[matrix.component] }}  # Build from component's tagged commit

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Quay.io
        uses: docker/login-action@v3
        with:
          registry: quay.io
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_PASSWORD }}

      - name: Extract version information
        id: version
        run: |
          # Extract full version (already has +N from update-versions job)
          full_version=$(grep '^version:' ${{ matrix.chart }} | awk '{print $2}')
          app_version=$(grep '^appVersion:' ${{ matrix.chart }} | awk '{print $2}' | tr -d '"')

          echo "full_version=$full_version" >> $GITHUB_OUTPUT
          echo "app_version=$app_version" >> $GITHUB_OUTPUT

          # Get short commit SHA (7 characters)
          short_sha=$(git rev-parse --short HEAD)
          echo "short_sha=$short_sha" >> $GITHUB_OUTPUT

          echo "Component: ${{ matrix.name }}"
          echo "  Full version: $full_version"
          echo "  App version (APP_VERSION): $app_version"
          echo "  Git SHA: $short_sha"

      - name: Build and push ${{ matrix.name }}
        uses: docker/build-push-action@v5
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.file }}
          push: true
          tags: |
            quay.io/yuvalturg/${{ matrix.name }}:${{ steps.version.outputs.full_version }}
            quay.io/yuvalturg/${{ matrix.name }}:${{ steps.version.outputs.short_sha }}
            quay.io/yuvalturg/${{ matrix.name }}:latest
          build-args: |
            APP_VERSION=${{ steps.version.outputs.app_version }}

  package-helm-charts:
    needs: [detect-changes, update-versions-and-tag]
    if: github.repository == 'rh-ai-quickstart/ai-architecture-charts' && needs.detect-changes.outputs.changed-components != ''
    runs-on: ubuntu-latest
    steps:
      - name: Checkout tagged commit
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.update-versions-and-tag.outputs.final-sha }}  # Package from final commit (includes all component bumps)

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: v3.14.0

      - name: Checkout gh-pages branch
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          path: gh-pages

      - name: Package charts
        run: |
          mkdir -p gh-pages
          read -ra CHANGED_COMPONENTS <<< "${{ needs.detect-changes.outputs.changed-components }}"
          for component in "${CHANGED_COMPONENTS[@]}"; do
            if [ -f "$component/helm/Chart.yaml" ]; then
              echo "Packaging helm chart for $component"
              helm dependency update "$component/helm"

              # Run pre-package script if it exists
              if [ -x "$component/scripts/pre-package.sh" ]; then
                echo "Running pre-package script for $component"
                "$component/scripts/pre-package.sh" "$component/helm"
              fi

              helm package "$component/helm" -d gh-pages
            fi
          done

      - name: Generate Helm index
        run: |
          helm repo index gh-pages --url https://rh-ai-quickstart.github.io/ai-architecture-charts --merge gh-pages/index.yaml

      - name: Commit and push to gh-pages
        run: |
          cd gh-pages
          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git add .
          git commit -m "Update Helm chart repo" || echo "No changes to commit"
          git push origin gh-pages
